# -*- coding: utf-8 -*-
"""
/***************************************************************************
 DeepSegmentationFrameworkDockWidget
                                 A QGIS plugin
 This plugin allows to perform segmentation with deep neural networks
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2022-08-11
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Przemyslaw Aszkowski
        email                : przemyslaw.aszkowski@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import logging
import os
from dataclasses import dataclass

from qgis.PyQt.QtWidgets import QComboBox
from qgis.PyQt import QtGui, QtWidgets, uic
from qgis.PyQt.QtCore import pyqtSignal
from qgis.core import QgsVectorLayer
from qgis.core import QgsRasterLayer
from qgis.core import QgsMessageLog
from qgis.core import QgsProject
from qgis.core import QgsVectorLayer
from qgis.core import Qgis
from PyQt5.QtWidgets import QInputDialog, QLineEdit

from deep_segmentation_framework.common.defines import PLUGIN_NAME, LOG_TAB_NAME
from deep_segmentation_framework.common.inference_parameters import InferenceParameters

FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'deep_segmentation_framework_dockwidget_base.ui'))


@dataclass
class InferenceInput:
    inference_parameters: InferenceParameters
    input_layer_id: str


class DeepSegmentationFrameworkDockWidget(QtWidgets.QDockWidget, FORM_CLASS):

    closingPlugin = pyqtSignal()
    do_something_signal = pyqtSignal()  # signal used for quick testing
    run_inference_signal = pyqtSignal(InferenceInput)

    def __init__(self, parent=None):
        """Constructor."""
        super(DeepSegmentationFrameworkDockWidget, self).__init__(parent)
        self.setupUi(self)
        self._create_connections()
        QgsMessageLog.logMessage("Widget setup", LOG_TAB_NAME, level=Qgis.Info)
        self._available_input_layers = {}  # type: Dict[str, str]  # id, name

    def _create_connections(self):
        self.pushButton_doSomething.clicked.connect(self._do_something)
        self.pushButton_run_inference.clicked.connect(self._run_inference)

    def _do_something(self):
        self.do_something_signal.emit()

    def update_input_layer_selection(self, all_layers):
        combobox = self.comboBox_inputLayer  # type: QComboBox
        if combobox.count() > 0:
            selected_item_index = combobox.currentIndex()
            selected_item_id = list(self._available_input_layers.keys())[selected_item_index]
        else:
            selected_item_id = None

        self._available_input_layers = {}
        for layer_id, layer in all_layers.items():
            if not isinstance(layer, QgsRasterLayer):
                continue  # not a vector layer - ignore
            name = layer.name()
            self._available_input_layers[layer_id] = name

        combobox.clear()
        for name in self._available_input_layers.values():
            combobox.addItem(name)

        # discard previously selected item, if it is no longer available:
        if selected_item_id not in self._available_input_layers:
            selected_item_id = None

        if not selected_item_id:
            # if none item is selected, and 'fotomapa' is available, select it,
            # as it is usually the layer we are looking for
            for layer_id, name in self._available_input_layers.items():
                if 'fotomapa' in name:
                    selected_item_id = layer_id
                    break

        if selected_item_id:
            index_of_selected_item_id = list(self._available_input_layers.keys()).index(selected_item_id)
            combobox.setCurrentIndex(index_of_selected_item_id)
            #  TODO: save selected_item as project plugin parameter the last selection
            #  (so it will be selected next time project starts)

    def _get_input_layer_selected_id(self):
        combobox = self.comboBox_inputLayer  # type: QComboBox
        index = combobox.currentIndex()
        return list(self._available_input_layers.keys())[index]

    def get_inference_parameters(self, mask_layer_name:str) -> InferenceParameters:
        postprocessing_dilate_erode_size = self.spinBox_dilateErodeSize.value() \
                                         if self.checkBox_removeSmallAreas.isChecked() else 0

        inference_parameters = InferenceParameters(
            resolution_cm_per_px=self.doubleSpinBox_resolution_cm_px.value(),
            tile_size_px=self.spinBox_tileSize_px.value(),
            entire_field=self.radioButton_inferenceEntireField.isChecked(),
            mask_layer_name=mask_layer_name,
            postprocessing_dilate_erode_size=postprocessing_dilate_erode_size,
        )
        return inference_parameters

    def _run_inference(self):
        if self.radioButton_inferencePolygonPart.isChecked():
            qid = QInputDialog()
            vals = [layer.name() for layer in QgsProject.instance().mapLayers().values() if isinstance(layer, QgsVectorLayer)]
            mask_layer_name, ok = QInputDialog.getItem( qid, "Select layer", "Select mask layer to processing", vals, 0, False)

            if not ok:
                msg = "Error! Layer not selected! Try again."
                QgsMessageLog.logMessage(PLUGIN_NAME, msg, level=Qgis.Critical)
                return
        else:
            mask_layer_name = None

        inference_parameters = self.get_inference_parameters(mask_layer_name=mask_layer_name)
        inference_input = InferenceInput(
            inference_parameters=inference_parameters,
            input_layer_id=self._get_input_layer_selected_id(),
        )
        self.run_inference_signal.emit(inference_input)

    def closeEvent(self, event):
        self.closingPlugin.emit()
        event.accept()

